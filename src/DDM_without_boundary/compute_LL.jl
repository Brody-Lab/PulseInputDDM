function compute_LL(data, params)


# Set up variables
NLL = 0;
if length(params) == 8
    bias  = params[7];
    lapse = params[8];
elseif length(params) == 7
#    bias  = params[6];
#    lapse = params[7];
    bias = params[7];
    lapse = 0;
else
    bias  = params[5];
    lapse = params[6];
end

# iterate over trials
for i=1:length(data["hit"])
    ma,va = compute_trial(data,i,params);

    # compute pr, pl with bias
    pr = 0.5*(1+erf( -(bias-ma)/sqrt(2*va)));
    pl = 1-pr;

    # compute pr, pl with lapse
    PR = (1-lapse)*pr + lapse*0.5;
    PL = (1-lapse)*pl + lapse*0.5;


    # checking for log() stability
#    if PR == 0
#        PR = eps();
#    end
#    if PL == 0
#        PL = eps();
#    end

    # compute NLL for this trial
    if data["pokedR"][i] 
        nll = -log(PR);
    else
        nll = -log(PL);
    end
    
    # add to total over all trials
    NLL += nll;
end

# exponential prior
#on brodycomp: sum(p.prior.*params)
# prior: 0.31, 0.94
#NLL += params[2]*0.31 + params[4]*0.94;

# Gaussian prior
# on brodycomp: params(2)^2/(2*p.prior(2)^2) + params(4)^2/(2*p.prior(4)^2);
# prior: 5.39, 1.87
NLL += (params[2]^2)/(2*5.39^2) + (params[4]^2)/(2*1.87^2);

### HACK ALERT for high gamma rats
# prior from H065 fits
#prior     = [0, 5.39,   1.49, 1.87,       0.14,      0.0040,      0,      0];
#mean_prior= [0, 0,      7.91, 0,          0.064,      0.019,      0,      0];
# prior from H067 fits
#prior     = [0, 5.39,   0.49, 1.87,       0.065,      0.026,      0,      0];
#mean_prior= [0, 0,      2.40, 0,          0.22,       0.095,      0,      0];

#NLL += (params[2]^2)/(2*5.39^2) + (params[4]^2)/(2*1.87^2) + (params[5] - mean_prior[5])^2/(2*prior[5]^2) + (params[6]-mean_prior[6])^2/(2*prior[6]^2) + (params[3]-mean_prior[3])^2/(2*prior[3]^2);

return NLL
end



function compute_trial(data, i, params);
    # just a check to handle empty arrays generated by synthetic sampling
    if length(data["leftbups"][i]) == 0
        data["leftbups"][i] = [0];
    end
    if length(data["rightbups"][i]) == 0
        data["rightbups"][i] = [0];
    end

    # run clicks through the adaptation process  
    if length(params) == 8
        cl, cr = make_adapted_cat_clicks(data["leftbups"][i], data["rightbups"][i], params[5],params[6]);
    elseif length(params) == 7
#        cl, cr = make_adapted_cat_clicks(data["leftbups"][i], data["rightbups"][i], params[4],params[5]);
        cl, cr = make_adapted_cat_clicks(data["leftbups"][i], data["rightbups"][i], params[5],params[6]);
    elseif length(params) == 6;
        cl, cr = make_adapted_cat_clicks(data["leftbups"][i], data["rightbups"][i], params[3],params[4]);
    end

    clicks = [-cl cr];
    times = [data["leftbups"][i] data["rightbups"][i]];

    # compute mean of distribution
    mean_a = 0;
    for j=1:length(clicks)
        mean_a += clicks[j]*exp(params[1]*(data["T"][i]-times[j]));
    end

    # compute variance of distribution
    # three sources: initial (params[4]), accumulation (params[2]), and per-click (params[3])
    
    if length(params) == 8
        a_var    = params[2];
        c_var    = params[3];
        init_var = params[4];
    elseif length(params) == 7
#        a_var    = params[2];
#        c_var    = params[3];
#        init_var = 0;
        a_var    = params[2];
        c_var    = params[3];
        init_var = params[4];
    elseif length(params) == 6
        a_var    = 0;;
        c_var    = params[2];
        init_var = 0;
    end
    
    # Initial and accumulation variance
    if abs(params[1]) < 1e-10
        s2 = init_var*exp(2*params[1]*data["T"][i]) + a_var*data["T"][i];
    else
        s2 = init_var*exp(2*params[1]*data["T"][i]) + (a_var/(2*params[1]))*(exp(2*params[1]*data["T"][i])-1);
    end
    
    # add per-click variance
    for j=1:length(clicks)
        s2 += c_var*abs(clicks[j])*exp(2*params[1]*(data["T"][i] - times[j]));
    end

    var_a = s2;

    # return mean and variance of distribution
    return mean_a, var_a
end

